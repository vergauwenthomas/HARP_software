library(stringi)
library(harp)



#read_station_meta_data
read_station_df <- function(stations_meta_file){
  relevant_cols = c('station', 'lat', 'lon','height', 'network', 'LCZ', 'priority')
  
  station_df = read_csv(stations_meta_file) %>% #read data
    select(relevant_cols) %>% #subset only relevant columns
    distinct() %>% #remove duplicate rows, introduced by the buffer radius column
    arrange(network) %>% #sort by network, so theire is some logic in SID's
    rename(elev = height) %>% 
    mutate(
      station = as.character(station), LCZ = as.character(LCZ), network = as.character(network),
      lat = as.numeric(lat), lon = as.numeric(lon), elev = as.numeric(elev), priority = as.numeric(priority)
    )
  
  
  
  station_df$SID = as.numeric(as_factor(station_df$station))
  return(station_df)
}

  







read_observations <- function(obsfolder, stationdf) {
  " Read all observation files, generated by titan, into one tibble dataframe. Merge the observations with the sid's using station-df.
      All files in the obsfolder (=path to the folder containing the data .txt files) are read. "
  
  
  obs_files = file.path(obsfolder, list.files(obsfolder))
  obs = data.frame()
  for (obs_file in obs_files){
    #read data
    sub_obs = read.csv(obs_file, sep=';')
    #get datetime 
    dt_char = stri_sub(obs_file, -15, -5) #this should be something like "20200801T05"
    mydate = strptime(dt_char,format='%Y%m%dT%H') #convert to POSIXct
    sub_obs$validdate = mydate
    obs = rbind(obs, sub_obs)
  }
  
  # convert units to K
  cat('Tempereture converted to Kelvin \n')
  obs$value = obs$value + 273.15
  obs$units = 'K'
  
  #convert to tibble
  obs = as_tibble(obs)
  
  #merge stationdf SID column
  to_merge_columns = stationdf %>% select(c('station', 'network', 'LCZ', 'SID'))
  obs = obs %>% inner_join(to_merge_columns,by="station")
  
  #data formatting
  obs =  obs %>% rename(t2m_observed = value) %>%
    mutate(
      station = as.character(station), quality_flag = as.character(quality_flag),
      lat = as.numeric(lat), lon = as.numeric(lon), elev = as.numeric(elev), t2m_observed = as.numeric(t2m_observed)
    ) %>%
    select(c('validdate', 'station', 'SID', 't2m_observed', 'units', 'quality_flag', 'lat', 'lon', 'elev', 'network', 'LCZ'))
  
  
  cat('Observations found for these datetimes: \n')
  print(obs %>% distinct(validdate) %>% pull())
  return(obs)
}





add_observations_to_fc <- function(fcst, observations){
  fcst_dates = (bind_fcst(fcst) %>% distinct(validdate) %>% lapply(. %>% as.character))$validdate #get unique dates as characters
  fcst_joined = join_to_fcst(fcst, observations,
                             join_type = 'inner', #TODO: er geraken rijen in de fc verloren, hoe komt dit?
                             by=c('SID', 'validdate'))
  fcst_joined_dates = (bind_fcst(fcst_joined) %>% distinct(validdate) %>% lapply(. %>% as.character))$validdate #get unique dates as characters
  cat('no overlap between FC and observations found for: \n')
  print(setdiff(fcst_dates, fcst_joined_dates))
  
  return(fcst_joined)
}





plot_at_station_level <- function(fcst, figure_folder, save, use_ggplot_bool, dateresolution = "1h"){
  
  
  
  
  startdate = bind_fcst(fcst) %>% select(validdate) %>% filter(validdate == min(validdate)) %>% first() %>% first()
  enddate = bind_fcst(fcst) %>% select(validdate) %>% filter(validdate == max(validdate)) %>% first() %>% first()
  
  
  stationname = bind_fcst(fcst) %>% select(station) %>% unique() %>% as.character
  model = bind_fcst(fcst) %>% select(mname) %>% unique() %>% as.character

  filename = paste0('T2m_at_', stationname,'_for_', model, '.png')
  file_path = file.path(figure_folder,filename)
  
  
  
  fcst_at_station = bind_fcst(fcst) %>% mutate(validdate = unix2datetime(validdate))
  if (use_ggplot_bool){
    plot = fcst_at_station %>%
      ggplot(aes(validdate, forecast, colour = mname)) +
      geom_line() +
      geom_point(aes(y = t2m_observed, shape = "Observation"), colour = "blue") +
      scale_shape_manual(values = 21) +
      facet_wrap(vars(fcst_cycle), ncol = 1) +
      scale_x_datetime(
        breaks = lubridate::ymd_hm(seq_dates(as.character(startdate,'%Y%m%d%H'),
                                             as.character(enddate,'%Y%m%d%H'),
                                             dateresolution))
      ) + 
      labs(
        x      = "Date-time",
        y      = bquote("T2m [K]"),
        colour = "",
        title  = paste0("Forecast T2m at ", stationname),
        shape  = ""
      ) +
      theme_bw() +
      theme(legend.position = "bottom")
    print(plot)
    
    if (save){
      ggsave(
        file_path,
        plot = plot,
        device = NULL,
        path = NULL,
        scale = 1,
        width = NA,
        height = NA,
        units = c("in", "cm", "mm", "px"),
        dpi = 300,
        limitsize = TRUE,
        bg = NULL
      )
      
      cat("figure saved as: ", file_path, '\n')
    }
    
  }else{
    
    graphics.off()
    
    #get min max values for the axis ranges
    maxy = fcst_at_station %>% select(c('forecast', 't2m_observed')) %>% max()
    miny = fcst_at_station %>% select(c('forecast', 't2m_observed')) %>% min()
    if (save){
      png(file=file_path,width=1200,height=400, res=45)
    }
    #make plot
    plot(fcst_at_station$validdate, fcst_at_station$t2m_observed,
         type='p',
         col='blue',
         xlab = "Date-time",
         ylab = "T2m [K]",
         ylim = c(miny, maxy))
    lines(fcst_at_station$validdate, fcst_at_station$forecast,
          type='l',
          col='red',
    )
    grid(nx = NULL, ny = NULL,
         lty = 2,      # Grid line type
         col = "gray", # Grid line color
         lwd = 2)      # Grid line width
    
    # Adding a legend
    legend("bottomright",
           legend = c(model, "Observation"),
           lwd = 1,
           col = c("red", "blue"))
    
    #adding title
    title(paste0("Forecast T2m at ", stationname))
    
    if (save){
      cat("figure saved as: ", file_path, '\n')
      dev.off()
    }
  }
}


















plot_basic_scores <- function(fcst, model, only_synop, figure_folder, save, use_ggplot_bool){
  " A function to plot the basic scores for a forcast. Make shure the observations are added to the forcast so a column T2m_observed is in the forecast"
  
  
  
  if (only_synop) {
    fcst[[model]] = fcst[[model]] %>% filter(network=='synop' | network=='knmi')
    title_addition = 'based on RMI and KNMI synop stations'
    filename = file.path(figure_folder,paste0('T2m_scores_for_', model, '_synop_only.png'))
  }else{
    title_addition = 'based on all stations'
    filename = file.path(figure_folder,paste0('T2m_scores_for_', model, '.png'))
  }
  
  
  
  
  #check if the forecast conatains multiple stations
  nstations_contained = bind_fcst(fcst) %>% select(station) %>% unique() %>% count() %>% as.numeric
  if (nstations_contained == 1){
    stationname_used = bind_fcst(fcst) %>% select(station) %>% unique() %>% as.character
    title_addition = paste0('using ', stationname_used)
    filename = file.path(figure_folder,paste0('T2m_scores_for_', model, '_by_', stationname_used, '.png'))
  }
  
  
  
  
  scores = det_verify(fcst, parameter = t2m_observed)$det_summary_scores
  print(scores)
  
  if (use_ggplot_bool){
    plot = scores %>% pivot_longer(cols = c('rmse', 'mae', 'bias', 'stde')) %>% select(-num_cases) %>%
      ggplot(aes(leadtime, value, colour = name)) +
      geom_line() +
      facet_wrap(vars(mname), ncol = 1) +
      labs(
        x      = "leadtime",
        y      = bquote("score-specific"),
        colour = "Scores",
        title  = paste0("Basic scores ", title_addition)
      ) +
      theme_bw() +
      theme(legend.position = "bottom")
    print(plot)
    
    if (save){
      ggsave(
        filename,
        plot = plot,
        device = NULL,
        path = NULL,
        scale = 1,
        width = NA,
        height = NA,
        units = c("in", "cm", "mm", "px"),
        dpi = 300,
        limitsize = TRUE,
        bg = NULL
      )
      cat("figure saved as: ", filename, '\n')
      
    }
    
  }else{ #use standard plotting R functions
    graphics.off()
    
    #get min max values for the axis ranges
    maxy = scores %>% select(c('bias', 'rmse', 'mae', 'stde')) %>% max()
    miny = scores %>% select(c('bias', 'rmse', 'mae', 'stde')) %>% min()
    if (save){
      png(file=filename)
    }
    #make plot
    plot(scores$leadtime, scores$bias,
         type='l',
         col='red',
         xlab = "Leadtime",
         ylab = "Score specific",
         ylim = c(miny, maxy))
    lines(scores$leadtime, scores$rmse,
          type='l',
          col='cyan',
    )
    lines(scores$leadtime, scores$mae,
          type='l',
          col='green',
    )
    lines(scores$leadtime, scores$stde,
          type='l',
          col='purple',
    )
    
    # Adding a legend
    legend("bottomright",
           legend = c("bias", "rmse", 'mae', 'stde'),
           lwd = 1,
           col = c("red", "cyan", 'green', 'purple'))
    
    #adding title
    title(paste0("Basic scores for ", model))
    if (save){
      cat("figure saved as: ", filename, '\n')
      dev.off()
    }
  }
}
