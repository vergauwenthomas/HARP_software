library(stringi)
library(harp)



#read_station_meta_data
read_station_df <- function(stations_meta_file){
  relevant_cols = c('station', 'lat', 'lon','height', 'network', 'LCZ', 'priority')
  
  station_df = read_csv(stations_meta_file) %>% #read data
    select(relevant_cols) %>% #subset only relevant columns
    distinct() %>% #remove duplicate rows, introduced by the buffer radius column
    arrange(network) %>% #sort by network, so theire is some logic in SID's
    rename(elev = height) %>% 
    mutate(
      station = as.character(station), LCZ = as.character(LCZ), network = as.character(network),
      lat = as.numeric(lat), lon = as.numeric(lon), elev = as.numeric(elev), priority = as.numeric(priority)
    )
  
  
  
  station_df$SID = as.numeric(as_factor(station_df$station))
  return(station_df)
}

  







read_observations <- function(obsfolder, stationdf) {
  " Read all observation files, generated by titan, into one tibble dataframe. Merge the observations with the sid's using station-df.
      All files in the obsfolder (=path to the folder containing the data .txt files) are read. "
  
  
  obs_files = file.path(obsfolder, list.files(obsfolder))
  obs = data.frame()
  for (obs_file in obs_files){
    #read data
    sub_obs = read.csv(obs_file, sep=';')
    #get datetime 
    dt_char = stri_sub(obs_file, -15, -5) #this should be something like "20200801T05"
    mydate = strptime(dt_char,format='%Y%m%dT%H') #convert to POSIXct
    sub_obs$validdate = mydate
    obs = rbind(obs, sub_obs)
  }
  
  # convert units to K
  cat('Tempereture converted to Kelvin \n')
  obs$value = obs$value + 273.15
  obs$units = 'K'
  
  #convert to tibble
  obs = as_tibble(obs)
  
  #merge stationdf SID column
  to_merge_columns = stationdf %>% select(c('station', 'network', 'LCZ', 'SID'))
  obs = obs %>% inner_join(to_merge_columns,by="station")
  
  #data formatting
  obs =  obs %>% rename(t2m_observed = value) %>%
    mutate(
      station = as.character(station), quality_flag = as.character(quality_flag),
      lat = as.numeric(lat), lon = as.numeric(lon), elev = as.numeric(elev), t2m_observed = as.numeric(t2m_observed)
    ) %>%
    select(c('validdate', 'station', 'SID', 't2m_observed', 'units', 'quality_flag', 'lat', 'lon', 'elev', 'network', 'LCZ'))
  
  
  cat('Observations found for these datetimes: \n')
  print(obs %>% distinct(validdate) %>% pull())
  return(obs)
}





add_observations_to_fc <- function(fcst, observations){
  fcst_dates = (bind_fcst(fcst) %>% distinct(validdate) %>% lapply(. %>% as.character))$validdate #get unique dates as characters
  fcst_joined = join_to_fcst(fcst, observations,
                             join_type = 'inner', #TODO: er geraken rijen in de fc verloren, hoe komt dit?
                             by=c('SID', 'validdate'))
  fcst_joined_dates = (bind_fcst(fcst_joined) %>% distinct(validdate) %>% lapply(. %>% as.character))$validdate #get unique dates as characters
  cat('no overlap between FC and observations found for: \n')
  print(setdiff(fcst_dates, fcst_joined_dates))
  
  return(fcst_joined)
}





plot_at_station_level <- function(fcst, stationname, dateresolution = "1h"){
  
  
  startdate = bind_fcst(fcst) %>% select(validdate) %>% filter(validdate == min(validdate)) %>% first() %>% first()
  enddate = bind_fcst(fcst) %>% select(validdate) %>% filter(validdate == max(validdate)) %>% first() %>% first()
  
  #check if station is in the FC, and ask for new stationname until it is found
  station_found = FALSE
  while (station_found == FALSE){
    if (!(stationname %in% bind_fcst(fcst)$station)){
      cat('SID Not found! \n')
      
      available_stations = bind_fcst(fcst) %>% distinct(station) 
      cat('Choose one of the following: \n')
      print(available_stations)
      stationname <- readline(prompt="Type stationname: ")
    }else{
      specific_sid = bind_fcst(fcst) %>% filter(station  == stationname) %>% select(SID) %>% first() %>% first()
      cat('SID is found: ', stationname, ' --> ', specific_sid, '\n')
      station_found = TRUE
    }
  }
  
  
  fcst_at_station = bind_fcst(fcst) %>% filter(SID == specific_sid) %>% mutate(validdate = unix2datetime(validdate))
  
  plot = fcst_at_station %>%
    ggplot(aes(validdate, forecast, colour = mname)) +
    geom_line() +
    geom_point(aes(y = t2m_observed, shape = "Observation"), colour = "blue") +
    scale_shape_manual(values = 21) +
    facet_wrap(vars(fcst_cycle), ncol = 1) +
    scale_x_datetime(
      breaks = lubridate::ymd_hm(seq_dates(as.character(startdate,'%Y%m%d%H'),
                                           as.character(enddate,'%Y%m%d%H'),
                                           dateresolution))
    ) + 
    labs(
      x      = "Date-time",
      y      = bquote("T2m [K]"),
      colour = "",
      title  = paste0("Forecast T2m at ", stationname),
      shape  = ""
    ) +
    theme_bw() +
    theme(legend.position = "bottom")
  print(plot)
  return(plot)
}


plot_basic_scores <- function(fcst){
  " A function to plot the basic scores for a forcast. Make shure the observations are added to the forcast so a column T2m_observed is in the forecast"
  
  scores = det_verify(fcst, parameter = t2m_observed)$det_summary_scores
  print(scores)
  
  
  
  plot = scores %>% pivot_longer(cols = c('rmse', 'mae', 'bias', 'stde')) %>% select(-num_cases) %>%
        ggplot(aes(leadtime, value, colour = name)) +
        geom_line() +
        facet_wrap(vars(mname), ncol = 1) +
        labs(
        x      = "leadtime",
        y      = bquote("score-specific"),
        colour = "Scores",
        title  = paste0("Basic scores")
      ) +
      theme_bw() +
      theme(legend.position = "bottom")
  print(plot)
  return(plot)
  }
